<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monotone Convergence Theorem</title>
    
    <!-- KaTeX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>

    <style>
        :root {
            --bg: #18181b;
            --panel: #27272a;
            --sidebar: #09090b;
            --text: #e4e4e7;
            --accent: #10b981; /* Emerald */
            --point: #38bdf8; /* Sky Blue */
            --bound: #ef4444; /* Red */
            --sup: #f59e0b; /* Amber */
            --epsilon: #d946ef; /* Fuchsia */
            --border: #3f3f46;
        }

        body { margin: 0; font-family: 'Segoe UI', system-ui, sans-serif; background: var(--bg); color: var(--text); height: 100vh; display: flex; flex-direction: column; overflow: hidden; }

        /* Header */
        header { background: var(--sidebar); border-bottom: 1px solid var(--border); display: flex; justify-content: center; padding: 0 20px; }
        .tab-btn { background: transparent; border: none; color: #71717a; padding: 15px 30px; font-weight: bold; cursor: pointer; border-bottom: 3px solid transparent; transition: all 0.2s; font-size: 1rem; }
        .tab-btn:hover { color: var(--text); }
        .tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); }

        /* Layout */
        main { flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px; overflow: hidden; }
        
        .stage-area { width: 100%; max-width: 1000px; display: flex; flex-direction: column; gap: 20px; }
        
        .visual-wrapper { 
            background: #000; border-radius: 12px; border: 1px solid var(--border); 
            height: 400px; position: relative; display: flex; justify-content: center; align-items: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3); overflow: hidden;
        }
        canvas { width: 100%; height: 100%; object-fit: contain; }

        /* Text Overlay */
        #textOverlay {
            display: none; width: 100%; height: 100%; padding: 40px; box-sizing: border-box;
            background: var(--panel); overflow-y: auto; font-size: 1.1rem; line-height: 1.8;
        }
        #textOverlay h2 { margin-top: 0; color: var(--accent); border-bottom: 1px solid var(--border); padding-bottom: 10px; }
        .proof-step { margin-bottom: 15px; }

        .controls { background: var(--panel); padding: 25px; border-radius: 12px; border: 1px solid var(--border); }
        
        .step-indicator { display: flex; justify-content: space-between; margin-bottom: 25px; font-size: 0.9rem; color: #a1a1aa; }
        .step { position: relative; z-index: 1; cursor: pointer; transition: color 0.2s; text-align: center; }
        .step:hover { color: var(--text); }
        .step.active { color: var(--accent); font-weight: bold; border-bottom: 2px solid var(--accent); }
        
        .explanation { min-height: 100px; margin-bottom: 20px; line-height: 1.6; font-size: 1.05rem; }
        .explanation h3 { margin: 0 0 10px 0; color: var(--accent); }

        .btn-group { display: flex; gap: 15px; justify-content: flex-end; }
        button.nav-btn { padding: 12px 24px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; background: var(--sidebar); color: var(--text); transition: all 0.2s; font-size: 1rem; }
        button.nav-btn:hover { background: var(--border); }
        button.nav-btn.primary { background: var(--accent); color: #000; }
        button.nav-btn.primary:hover { background: #34d399; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }

    </style>
</head>
<body>

<header>
    <button class="tab-btn active" onclick="App.setTab(0)">1. The Behavior</button>
    <button class="tab-btn" onclick="App.setTab(1)">2. The Proof</button>
</header>

<main>
    <div class="stage-area">
        <div class="visual-wrapper">
            <canvas id="mathCanvas"></canvas>
            <div id="textOverlay"></div>
        </div>
        
        <div class="controls">
            <div class="step-indicator" id="stepIndicator"></div>
            
            <div class="explanation">
                <h3 id="stepTitle">Title</h3>
                <div id="stepDesc">Description</div>
            </div>
            
            <div class="btn-group">
                <button class="nav-btn" onclick="App.prev()" id="prevBtn" disabled>Back</button>
                <button class="nav-btn primary" onclick="App.next()" id="nextBtn">Next Step</button>
            </div>
        </div>
    </div>
</main>

<script>
    function renderMath(element) {
        if (!window.renderMathInElement) return;
        renderMathInElement(element, {
            delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]
        });
    }

    const App = {
        tab: 0,
        step: 0,
        canvas: document.getElementById('mathCanvas'),
        ctx: document.getElementById('mathCanvas').getContext('2d'),
        overlay: document.getElementById('textOverlay'),

        // Points cache
        seqPoints: [],

        modules: [
            // PART 1: The Behavior
            {
                steps: [
                    { title: "1. Monotonicity", desc: "A sequence $(a_n)$ is <strong>Monotone Increasing</strong> if $a_{n+1} \\ge a_n$ for all $n$. It effectively only goes up (or stays flat). It cannot oscillate." },
                    { title: "2. Unbounded Growth", desc: "If the sequence is monotone but NOT bounded, it will grow towards $+\\infty$. It never converges to a real number." },
                    { title: "3. Boundedness", desc: "If we add an Upper Bound $M$ (Red Line), the monotone sequence cannot pass it. It hits a 'ceiling'." },
                    { title: "4. Convergence", desc: "Intuitively, since it must go up but cannot cross the ceiling, it must crowd together and converge to some limit $L \\le M$." }
                ]
            },
            // PART 2: The Proof
            {
                steps: [
                    { title: "1. The Set of Terms", desc: "Let $S = \\{a_n : n \\in \\mathbb{N}\\}$ be the set of values in the sequence. Since $(a_n)$ is bounded, the set $S$ is bounded above." },
                    { title: "2. The Supremum", desc: "By the Completeness Axiom of $\\mathbb{R}$, $S$ must have a Least Upper Bound. Let $L = \\sup S$ (Amber Line). This is our candidate for the limit." },
                    { title: "3. The Epsilon Gap", desc: "Let $\\epsilon > 0$. Consider the line $L - \\epsilon$ (Purple). Since $L$ is the *Least* Upper Bound, $L - \\epsilon$ is NOT an upper bound." },
                    { title: "4. Crossing the Gap", desc: "Therefore, there must be some term $a_N$ (Highlighted) such that $a_N > L - \\epsilon$. It enters the 'Epsilon Strip'." },
                    { title: "5. The Monotone Trap", desc: "Because the sequence is increasing, for ALL $n \\ge N$, we have $a_n \\ge a_N > L - \\epsilon$. Also $a_n \\le L$. Thus $a_n \\in (L-\\epsilon, L]$. Convergence proved." },
                    { title: "6. Formal Proof", desc: "Review the logic text above.", isText: true, content: `
                        <h2>Monotone Convergence Theorem</h2>
                        <div class="proof-step"><strong>Theorem:</strong> If a sequence $(a_n)$ is monotone increasing and bounded above, it converges.</div>
                        <div class="proof-step"><strong>Proof:</strong></div>
                        <div class="proof-step">1. Let $S = \\{a_n\\}$ be the range of the sequence. Since bounded, $S$ is bounded above.</div>
                        <div class="proof-step">2. By Completeness Axiom, let $L = \\sup S$. We claim $\\lim_{n\\to\\infty} a_n = L$.</div>
                        <div class="proof-step">3. Let $\\epsilon > 0$. Since $L$ is the supremum, $L-\\epsilon$ is not an upper bound.</div>
                        <div class="proof-step">4. Thus $\\exists N$ such that $a_N > L - \\epsilon$.</div>
                        <div class="proof-step">5. Since $(a_n)$ is increasing, $\\forall n \\ge N, a_n \\ge a_N$.</div>
                        <div class="proof-step">6. Combined with the bound: $L - \\epsilon < a_N \\le a_n \\le L < L + \\epsilon$.</div>
                        <div class="proof-step">7. Thus $|a_n - L| < \\epsilon$ for all $n \\ge N$. $\\blacksquare$</div>`
                    }
                ]
            }
        ],

        setTab(idx) {
            this.tab = idx;
            this.step = 0;
            document.querySelectorAll('.tab-btn').forEach((b, i) => b.classList.toggle('active', i === idx));
            this.generateSequence();
            this.updateUI();
            this.draw();
        },

        generateSequence() {
            this.seqPoints = [];
            let val = 0.5;
            // Generate a nice logistic-like curve approaching a limit
            // Limit L = 4.0
            const L = 4.0;
            for(let n=0; n<25; n++) {
                // Next value closes half the distance to L (Zeno's paradox style) with some randomness
                let gap = L - val;
                val = val + gap * (0.15 + Math.random() * 0.1); 
                this.seqPoints.push(val);
            }
        },

        next() {
            const max = this.modules[this.tab].steps.length - 1;
            if (this.step < max) { this.step++; this.updateUI(); this.draw(); }
        },
        prev() {
            if (this.step > 0) { this.step--; this.updateUI(); this.draw(); }
        },
        goto(i) {
            this.step = i; this.updateUI(); this.draw();
        },

        updateUI() {
            const data = this.modules[this.tab].steps[this.step];
            
            // Indicators
            const indicContainer = document.getElementById('stepIndicator');
            indicContainer.innerHTML = '';
            this.modules[this.tab].steps.forEach((s, i) => {
                const span = document.createElement('span');
                span.className = `step ${i === this.step ? 'active' : ''}`;
                span.innerText = (i+1) + ". " + (s.title.split('.')[1] || s.title); 
                span.onclick = () => App.goto(i);
                indicContainer.appendChild(span);
            });

            document.getElementById('stepTitle').innerText = data.title;
            const descEl = document.getElementById('stepDesc');
            descEl.innerHTML = data.desc;
            renderMath(descEl);

            if (data.isText) {
                this.canvas.style.display = 'none';
                this.overlay.style.display = 'block';
                this.overlay.innerHTML = data.content;
                renderMath(this.overlay);
            } else {
                this.canvas.style.display = 'block';
                this.overlay.style.display = 'none';
            }

            document.getElementById('prevBtn').disabled = this.step === 0;
            document.getElementById('nextBtn').disabled = this.step === this.modules[this.tab].steps.length - 1;
        },

        draw() {
            if(this.modules[this.tab].steps[this.step].isText) return;

            const ctx = this.ctx;
            const w = this.canvas.width;
            const h = this.canvas.height;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, w, h);

            // Coord System
            const pad = 60;
            const chartW = w - pad * 2;
            const chartH = h - pad * 2;
            
            // Y range [0, 5], X range [0, 25]
            const mapX = (n) => pad + (n / 25) * chartW;
            const mapY = (val) => (h - pad) - (val / 5) * chartH;

            // Draw Axes
            ctx.strokeStyle = '#3f3f46'; ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(pad, pad); ctx.lineTo(pad, h - pad); ctx.lineTo(w - pad, h - pad);
            ctx.stroke();

            // Draw Logic
            if(this.tab === 0) this.drawBehavior(ctx, mapX, mapY, chartW);
            else this.drawProof(ctx, mapX, mapY, chartW);
        },

        drawBehavior(ctx, mapX, mapY, w) {
            // Step 1: Just Points
            ctx.fillStyle = '#38bdf8';
            this.seqPoints.forEach((val, n) => {
                const x = mapX(n);
                const y = mapY(val);
                ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fill();
            });

            // Step 2: Unbounded (Ghost comparison)
            if(this.step === 1) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                for(let n=0; n<25; n++) {
                    const x = mapX(n);
                    const y = mapY(n * 0.2 + 0.5); // Linear growth
                    ctx.beginPath(); ctx.arc(x, y, 3, 0, Math.PI*2); ctx.fill();
                }
                ctx.fillStyle = '#fff'; ctx.fillText("Unbounded Example", mapX(10), mapY(2.8));
            }

            // Step 3: Upper Bound M
            if(this.step >= 2) {
                const M = 4.5; // Slightly higher than L=4
                const yM = mapY(M);
                ctx.strokeStyle = '#ef4444'; ctx.lineWidth = 2; ctx.setLineDash([5,5]);
                ctx.beginPath(); ctx.moveTo(60, yM); ctx.lineTo(60 + w, yM); ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#ef4444'; ctx.fillText(`Upper Bound M = ${M}`, 70, yM - 10);
            }

            // Step 4: Convergence
            if(this.step === 3) {
                const L = 4.0;
                const yL = mapY(L);
                ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.moveTo(60, yL); ctx.lineTo(60 + w, yL); ctx.stroke();
                ctx.fillStyle = '#f59e0b'; ctx.fillText(`Limit L = ${L}`, 70, yL + 20);
            }
        },

        drawProof(ctx, mapX, mapY, w) {
            const L = 4.0;
            const epsilon = 0.5;
            const yL = mapY(L);
            const yEps = mapY(L - epsilon);

            // Points
            ctx.fillStyle = '#38bdf8';
            this.seqPoints.forEach((val, n) => {
                const x = mapX(n);
                const y = mapY(val);
                ctx.beginPath(); ctx.arc(x, y, 4, 0, Math.PI*2); ctx.fill();
            });

            // Step 2: Supremum
            if(this.step >= 1) {
                ctx.strokeStyle = '#f59e0b'; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(60, yL); ctx.lineTo(60 + w, yL); ctx.stroke();
                ctx.fillStyle = '#f59e0b'; ctx.fillText(`L = sup S`, 70, yL - 10);
            }

            // Step 3: Epsilon Line
            if(this.step >= 2) {
                ctx.strokeStyle = '#d946ef'; ctx.lineWidth = 2; ctx.setLineDash([5,5]);
                ctx.beginPath(); ctx.moveTo(60, yEps); ctx.lineTo(60 + w, yEps); ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#d946ef'; ctx.fillText(`L - epsilon`, 70, yEps + 20);
                
                // Highlight Strip
                ctx.fillStyle = 'rgba(217, 70, 239, 0.1)';
                ctx.fillRect(60, yL, w, yEps - yL);
            }

            // Step 4: Finding a_N
            if(this.step >= 3) {
                // Find first point > L - epsilon
                const N = this.seqPoints.findIndex(val => val > L - epsilon);
                if(N !== -1) {
                    const x = mapX(N);
                    const y = mapY(this.seqPoints[N]);
                    
                    // Highlight Point
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(x, y, 8, 0, Math.PI*2); ctx.stroke();
                    ctx.fillStyle = '#fff'; ctx.fillText(`a_N`, x - 10, y - 15);
                }
            }

            // Step 5: The Trap
            if(this.step === 4) {
                const N = this.seqPoints.findIndex(val => val > L - epsilon);
                // Highlight all points after N
                ctx.fillStyle = '#10b981';
                for(let n=N; n<this.seqPoints.length; n++) {
                    const x = mapX(n);
                    const y = mapY(this.seqPoints[n]);
                    ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill();
                }
                
                // Draw Arrow
                ctx.strokeStyle = '#10b981'; ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(mapX(N), mapY(L) + 40);
                ctx.lineTo(mapX(24), mapY(L) + 40);
                ctx.stroke();
                ctx.fillStyle = '#10b981'; ctx.fillText("Trapped!", mapX(N) + 40, mapY(L) + 60);
            }
        }
    };

    window.onload = () => {
        window.addEventListener('resize', () => {
            App.canvas.width = App.canvas.parentElement.clientWidth;
            App.canvas.height = App.canvas.parentElement.clientHeight;
            if(!App.modules[App.tab].steps[App.step].isText) App.draw();
        });
        App.canvas.width = App.canvas.parentElement.clientWidth;
        App.canvas.height = App.canvas.parentElement.clientHeight;
        App.setTab(0);
    };

</script>
</body>
</html>
