System Architecture: The Universal Snapshot Factory

Version: 1.0 (Stable)
Pattern: Generative Micro-Architecture (Client-Side Only)
Stack: Vanilla JS, Tailwind CSS, Gemini API, LocalStorage

1. Core Philosophy

The system replaces domain-specific application code with a single, universal engine. Instead of writing separate apps for "War", "Bible", or "Chemistry", we utilize a Meta-Configuration stored in the browser. The HTML/JS files are empty shells that hydrate their UI and Logic based on a JSON configuration object.

2. File Manifest (The "Infrastructure")

The application consists of exactly four files. No new files are created to add new domains.

A. The Architect (as-factory-admin/index.html)

Role: System Configurator.

Function: Accepts a natural language domain (e.g., "Chemistry"). Uses AI to generate a full JSON configuration (Colors, Persona, Guard Rails, Accordion Schemas).

Output: Saves config to localStorage key as-config-{slug}.

B. The Room (as-factory-room/index.html)

Role: Domain Entry & Context Switcher.

Function: Reads ?factory={slug}. Loads specific theme/title. Manages the list of "Contexts" (e.g., Factory: Chemistry -> Contexts: "Organic", "Inorganic").

State: Reads/Writes to as-{factory_slug}-list.

C. The Hub (as-factory-hub/index.html)

Role: Dashboard & Index.

Function: Reads ?factory={slug}&context={context_slug}. Lists generated items (e.g., "Benzene", "Methane").

State: Reads keys starting with as-{factory_slug}-{context_slug}-data-.

D. The Viewer (as-factory-viewer/index.html)

Role: Generation Engine.

Function: Reads config to build a dynamic AI Prompt. Injects specific "Guard Rails" and "Accordion Schemas" into the prompt. Renders the AI response into dynamic HTML.

3. Data Schema (LocalStorage)

The system relies on a strict naming convention for keys to prevent data collision between factories.

Data Type

Key Pattern

Content

Config

as-config-{factory_slug}

JSON object defining colors, titles, persona, and prompt structure.

Context List

as-{factory_slug}-list

Array of objects [{name: "Organic", slug: "organic"}].

Item Data

as-{factory_slug}-{context_slug}-data-{item_id}

The final generated report (JSON) for a specific item (Battle/Chapter/Molecule).

4. The Configuration Object

This is the "Brain" generated by the Admin tool. It drives the logic of the other three files.

{
  "slug": "chemistry",
  "theme": {
    "brand": "#00ff00",
    "bg_gradient_1": "#000000",
    "bg_gradient_2": "#1a1a1a"
  },
  "text": {
    "roomTitle": "The Lab",
    "hubTitle": "Compound Index",
    "unitNoun": "Molecule"
  },
  "ai": {
    "role": "PhD Chemist",
    "context": "Analyze chemical properties",
    "guardRails": "Reject non-chemical queries.",
    "sections": [
      { 
        "label": "Atomic Structure", 
        "icon": "⚛️", 
        "instruction": "Detail the electron configuration..." 
      }
      // ... 3 more sections
    ]
  }
}


5. Logic Flow: The "Snapshot" Generation

When a user requests an item (e.g., "Carbon") in the Viewer:

Hydration: Viewer loads as-config-chemistry.

Prompt Assembly: It reads config.ai.sections. It constructs a prompt telling the AI: "You are a [role]. Output JSON with these specific keys: [Atomic Structure, Reactivity, etc.]."

Generation: Gemini returns JSON matching that exact schema.

Rendering: The Viewer loops through config.ai.sections again to match the returned data with the correct Icons and Labels for the UI accordions.

6. Future Expansion Roadmap

Export/Import: Implement the JSON dump logic (from the War Room prototype) into the Factory Admin to allow moving configs and data between devices.

Edit Mode: Allow manual tweaking of the AI-generated config (e.g., changing a color or refining a prompt instruction) without re-generating the whole app.
